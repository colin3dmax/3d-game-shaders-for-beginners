<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="description" content="Interested in adding textures, lighting, shadows, normal maps, glowing objects, ambient occlusion, reflections, refractions, and more to your 3D game? Great! 3D Game Shaders For Beginners is a collection of shading techniques that will take your game visuals to new heights." />
    <meta property="og:title" content="screen space reflection | 3D Game
Shaders For Beginners" />
    <meta property="og:description" content="Interested in adding textures, lighting, shadows, normal maps, glowing objects, ambient occlusion, reflections, refractions, and more to your 3D game? Great! 3D Game Shaders For Beginners is a collection of shading techniques that will take your game visuals to new heights." />
    <meta property="og:image" content="https://i.imgur.com/JIDwVTm.png" />
    <meta name="twitter:title" content="screen space reflection | 3D
Game Shaders For Beginners" />
    <meta name="twitter:description" content="Interested in adding textures, lighting, shadows, normal maps, glowing objects, ambient occlusion, reflections, refractions, and more to your 3D game? Great! 3D Game Shaders For Beginners is a collection of shading techniques that will take your game visuals to new heights." />
    <meta name="twitter:image" content="https://i.imgur.com/JIDwVTm.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <meta name="author" content="David Lettier" />
    <title>screen space reflection | 3D Game Shaders For
Beginners</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
    </style>
    <style>
      html { -webkit-text-size-adjust: 100%; }
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          background-color: #232629;
          color: #7a7c7d;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #7a7c7d;  padding-left: 4px; }
      div.sourceCode
        { color: #cfcfc2; background-color: #232629; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span { color: #cfcfc2; } /* Normal */
      code span.al { color: #95da4c; background-color: #4d1f24; font-weight: bold; } /* Alert */
      code span.an { color: #3f8058; } /* Annotation */
      code span.at { color: #2980b9; } /* Attribute */
      code span.bn { color: #f67400; } /* BaseN */
      code span.bu { color: #7f8c8d; } /* BuiltIn */
      code span.cf { color: #fdbc4b; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #3daee9; } /* Char */
      code span.cn { color: #27aeae; font-weight: bold; } /* Constant */
      code span.co { color: #7a7c7d; } /* Comment */
      code span.cv { color: #7f8c8d; } /* CommentVar */
      code span.do { color: #a43340; } /* Documentation */
      code span.dt { color: #2980b9; } /* DataType */
      code span.dv { color: #f67400; } /* DecVal */
      code span.er { color: #da4453; text-decoration: underline; } /* Error */
      code span.ex { color: #0099ff; font-weight: bold; } /* Extension */
      code span.fl { color: #f67400; } /* Float */
      code span.fu { color: #8e44ad; } /* Function */
      code span.im { color: #27ae60; } /* Import */
      code span.in { color: #c45b00; } /* Information */
      code span.kw { color: #cfcfc2; font-weight: bold; } /* Keyword */
      code span.op { color: #cfcfc2; } /* Operator */
      code span.ot { color: #27ae60; } /* Other */
      code span.pp { color: #27ae60; } /* Preprocessor */
      code span.re { color: #2980b9; background-color: #153042; } /* RegionMarker */
      code span.sc { color: #3daee9; } /* SpecialChar */
      code span.ss { color: #da4453; } /* SpecialString */
      code span.st { color: #f44f4f; } /* String */
      code span.va { color: #27aeae; } /* Variable */
      code span.vs { color: #da4453; } /* VerbatimString */
      code span.wa { color: #da4453; } /* Warning */
    </style>
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
<p><a href="chromatic-aberration.html"><span class="emoji"
data-emoji="arrow_backward">◀️</span></a> <a href="../README.md"><span
class="emoji" data-emoji="arrow_double_up">⏫</span></a> <a
href="#"><span class="emoji" data-emoji="arrow_up_small">🔼</span></a>
<a href="#copyright"><span class="emoji"
data-emoji="arrow_down_small">🔽</span></a> <a
href="screen-space-refraction.html"><span class="emoji"
data-emoji="arrow_forward">▶️</span></a></p>
<h1 id="3d-游戏着色器入门">3D 游戏着色器入门</h1>
<h2 id="屏幕空间反射ssr">屏幕空间反射（SSR）</h2>
<p align="center">
<img src="../resources/images/AYG4tvg.gif" alt="Screen Space Reflections" title="Screen Space Reflections">
</p>

<p>添加反射可以让你的场景更具真实感。<br />
湿润和有光泽的物体会变得生动起来，没有什么比反射更能让物体看起来湿润或闪亮了。<br />
借助反射，你可以更好地营造出水面和金属物体的幻觉。</p>
<p>在<a
href="lighting.html">光照</a>部分，你模拟了光源的镜面反射图像。<br />
这是渲染镜面反射的过程。<br />
还记得我们是用反射光方向来计算镜面光的。<br />
类似地，使用屏幕空间反射（SSR）你可以模拟场景中其他物体的反射，而不仅仅是光源。<br />
这不再是从光源发出的光线反射进入摄像机，而是场景中某个物体发出的光线反射进入摄像机。</p>
<p>SSR 的工作原理是使用屏幕图像自身来对自身进行反射。<br />
这与使用六面贴图（立方体贴图）不同，后者使用六个视角的纹理。<br />
在立方体贴图中，你从场景中某点发出一条射线，并反射到包围整个场景的立方体内部的某一点。<br />
而在 SSR
中，你从屏幕上的一个点发出射线，并反射到屏幕上的另一个点。<br />
通过将屏幕反射到自己上面，你可以制造出反射的幻觉。<br />
这种幻觉在大多数情况下是有效的，但如你将看到的，它也有失效的时候。</p>
<h3 id="光线步进ray-marching">光线步进（Ray Marching）</h3>
<p>屏幕空间反射使用一种称为“光线步进”的技术来为每个片元确定反射。<br />
光线步进是一种迭代延展或缩短某个向量的长度（或大小）来在空间中探测或采样信息的方法。<br />
在屏幕空间反射中，反射光线是相对于法线方向反射后的位置向量。</p>
<p>直观上讲，一条光线打到场景中的某个点，<br />
发生反射，<br />
然后沿反射向量的相反方向传播，<br />
打到当前片元，<br />
再沿位置向量的相反方向传播，<br />
最终击中摄像机镜头，从而让你在当前片元中看到场景中某点的反射颜色。<br />
SSR 就是在反向追踪这条光线路径。<br />
它试图找出光线反射并击中当前片元的那个反射点。<br />
每次迭代时，<br />
算法会沿着反射光线采样场景的位置或深度，<br />
每次判断光线是否与场景几何体相交。<br />
如果有相交，<br />
那么这个位置就是当前片元可能反射的候选点。</p>
<p>理想情况下，应该有某种解析方法可以精确求出第一次相交的点。<br />
因为这个第一次相交点才是当前片元应该反射的唯一有效点。<br />
但实际上，这个方法更像是一场“战舰游戏”。<br />
你看不到是否有相交点，因此只能从反射光线的起点开始，沿着方向一个一个坐标“喊出来”。<br />
每喊一个，就看看是否“击中”。<br />
如果击中，<br />
你就围绕那个区域再尝试，希望找出准确的相交点。</p>
<p align="center">
<img src="../resources/images/wnAC7NI.gif" alt="SSR Ray Marching" title="SSR Ray Marching">
</p>

<p>这里展示了如何使用光线步进来计算每个片元的反射点。<br />
绿色亮箭头表示顶点法线，<br />
蓝色亮箭头是位置向量，<br />
红色亮箭头是通过视空间进行步进的反射射线。</p>
<h3 id="顶点位置">顶点位置</h3>
<p>与 SSAO 一样，你需要将顶点位置转换到视空间中。<br />
参见 <a href="ssao.html#vertex-positions">SSAO</a> 章节获取更多细节。</p>
<h3 id="顶点法线">顶点法线</h3>
<p>为了计算反射，你也需要将顶点法线转换到视空间中。<br />
参见 <a href="ssao.html#vertex-normals">SSAO</a> 章节获取更多细节。</p>
<p align="center">
<img src="../resources/images/1cE2vBY.gif" alt="SSR using normal maps." title="SSR using normal maps.">
</p>

<p>这里展示的是使用法线贴图中的法线进行 SSR，<br />
而不是使用顶点法线。<br />
注意反射如何随着水面波纹而变化，<br />
而不是之前所展示的那种镜面反射效果。</p>
<p>要使用法线贴图，<br />
你需要像在光照计算中那样将法线从切线空间变换到视空间。<br />
可以在 <a
href="../demonstration/shaders/fragment/normal.frag">normal.frag</a>
中看到这个过程。</p>
<h3 id="位置变换">位置变换</h3>
<p align="center">
<img src="../resources/images/Qnsvkc0.gif" alt="Position Transformations" title="Position Transformations">
</p>

<p>与 <a href="ssao.html">SSAO</a> 一样，SSR
也需要在屏幕空间和视空间之间来回转换。<br />
你需要相机镜头的投影矩阵来将视空间中的点变换到裁剪空间（clip
space）。<br />
再从裁剪空间转换到 UV 空间。<br />
在 UV 空间中，<br />
你可以从场景中采样顶点或片元位置，<br />
这些位置就是你采样点在场景中最接近的位置。<br />
这就是“屏幕空间反射”中的“屏幕空间”部分，<br />
因为“屏幕”本质上是一张映射到屏幕大小矩形上的 UV 纹理。</p>
<h3 id="反射的-uv-坐标">反射的 UV 坐标</h3>
<p>你可以用几种不同的方式来实现 SSR。<br />
示例代码是从计算每个屏幕片元的反射 UV 坐标开始反射过程的。<br />
你也可以跳过这一步，直接计算反射颜色，使用的是场景最终渲染的结果。</p>
<p>回忆一下，UV 坐标的 U 和 V 值范围都是从 0 到 1。<br />
屏幕本质上是一张映射到屏幕大小矩形上的 2D 纹理。<br />
知道这一点后，示例代码实际上不需要场景的最终渲染图像来计算反射。<br />
它可以直接计算每个屏幕像素最终要使用的 UV 坐标。<br />
这些计算出的 UV 坐标可以保存到帧缓冲纹理中，<br />
在渲染完成后再使用。</p>
<p align="center">
<img src="../resources/images/pkQcGkD.gif" alt="Reflected UVs" title="Reflected UVs">
</p>

<p>上图显示的是反射后的 UV 坐标。<br />
即使场景还没渲染出来，<br />
你也可以预先感受到反射大致会是什么样子。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>uniform mat4 lensProjection<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>uniform sampler2D positionTexture<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>uniform sampler2D normalTexture<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">//...</span></span></code></pre></div>
<p>你需要相机镜头的投影矩阵，以及视空间中插值得到的顶点位置和法线。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> maxDistance <span class="op">=</span> <span class="dv">15</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> resolution  <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>   steps       <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness   <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>与其他特效一样，SSR 有一些可以调节的参数。<br />
根据场景的复杂度，找到合适设置可能需要一些时间。<br />
当你要反射复杂几何体时，让 SSR 看起来“正确”会特别困难。</p>
<ul>
<li><p><code>maxDistance</code> 控制片元最多可以反射多远，<br />
换句话说，它决定了反射射线的最大长度或大小。</p></li>
<li><p><code>resolution</code>
控制反射射线第一次遍历时跳过多少片元。<br />
这第一次遍历用于找到射线进入或穿过某个几何体的粗略位置。<br />
可以认为它是“粗步”。<br />
注意，<code>resolution</code> 的范围是 0 到 1。<br />
值为 0 会导致没有反射，而值为 1 会逐片元检查沿射线方向的所有点。<br />
在大 <code>maxDistance</code> 值下，使用 1 的 <code>resolution</code>
会显著降低帧率。</p></li>
<li><p><code>steps</code> 控制第二次遍历中进行的迭代次数。<br />
这一次是为了找到射线与几何体精确相交的位置。<br />
可认为它是“精步”。</p></li>
<li><p><code>thickness</code> 决定哪些相交点算作命中，哪些不算。<br />
理想情况下，射线应该精确停在某个场景中的片元或深度位置上。<br />
那将是光线发生反射、打到当前片元、再进入相机的那个点。<br />
可惜计算不是总能精确命中，所以 <code>thickness</code>
给了我们一定的容差。<br />
你希望这个值尽可能小，只比采样位置或深度稍微大一点。</p></li>
</ul>
<p align="center">
<img src="../resources/images/W163Mfw.png" alt="Larger Thickness" title="Larger Thickness">
</p>

<p>你会发现 <code>thickness</code> 越大，反射越模糊、越容易“糊掉”。</p>
<p align="center">
<img src="../resources/images/T6uH4Yu.png" alt="Smaller Thickness" title="Smaller Thickness">
</p>

<p>相反地，如果 <code>thickness</code> 越小，<br />
反射会变得充满噪点，出现许多小洞和细缝。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>vec2 texSize  <span class="op">=</span> textureSize<span class="op">(</span>positionTexture<span class="op">,</span> <span class="dv">0</span><span class="op">).</span>xy<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>vec2 texCoord <span class="op">=</span> gl_FragCoord<span class="op">.</span>xy <span class="op">/</span> texSize<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>vec4 positionFrom     <span class="op">=</span> texture<span class="op">(</span>positionTexture<span class="op">,</span> texCoord<span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>vec3 unitPositionFrom <span class="op">=</span> normalize<span class="op">(</span>positionFrom<span class="op">.</span>xyz<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>vec3 normal           <span class="op">=</span> normalize<span class="op">(</span>texture<span class="op">(</span>normalTexture<span class="op">,</span> texCoord<span class="op">).</span>xyz<span class="op">);</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>vec3 pivot            <span class="op">=</span> normalize<span class="op">(</span>reflect<span class="op">(</span>unitPositionFrom<span class="op">,</span> normal<span class="op">));</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>获取当前片元的位置、法线以及关于法线的反射向量。<br />
<code>positionFrom</code> 是从摄像机到当前片元的向量。<br />
<code>normal</code> 是当前片元插值得到的法线方向。<br />
<code>pivot</code> 是将 <code>positionFrom</code>
相对于法线反射后得到的反射向量，<br />
其长度为 1。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>vec4 startView <span class="op">=</span> vec4<span class="op">(</span>positionFrom<span class="op">.</span>xyz <span class="op">+</span> <span class="op">(</span>pivot <span class="op">*</span>           <span class="dv">0</span><span class="op">),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>vec4 endView   <span class="op">=</span> vec4<span class="op">(</span>positionFrom<span class="op">.</span>xyz <span class="op">+</span> <span class="op">(</span>pivot <span class="op">*</span> maxDistance<span class="op">),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>计算视空间中反射射线的起点和终点。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>vec4 startFrag      <span class="op">=</span> startView<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">// 投影到屏幕空间</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>     startFrag      <span class="op">=</span> lensProjection <span class="op">*</span> startFrag<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">// 透视除法</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>     startFrag<span class="op">.</span>xyz <span class="op">/=</span> startFrag<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">// 屏幕空间 XY 转换为 UV 坐标</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>     startFrag<span class="op">.</span>xy   <span class="op">=</span> startFrag<span class="op">.</span>xy <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">// UV 转换为片元坐标</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>     startFrag<span class="op">.</span>xy  <span class="op">*=</span> texSize<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>vec4 endFrag      <span class="op">=</span> endView<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>     endFrag      <span class="op">=</span> lensProjection <span class="op">*</span> endFrag<span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>     endFrag<span class="op">.</span>xyz <span class="op">/=</span> endFrag<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>     endFrag<span class="op">.</span>xy   <span class="op">=</span> endFrag<span class="op">.</span>xy <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>     endFrag<span class="op">.</span>xy  <span class="op">*=</span> texSize<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>将起点和终点从视空间投影到屏幕空间。<br />
这两个点现在对应于屏幕上的片元像素位置。<br />
你可以在屏幕空间中沿着这条射线方向遍历。<br />
可以将这条射线想象成屏幕上的一条线，<br />
你将在这条线上进行步进，并在位置帧缓冲纹理中采样对应的片元位置。</p>
<p align="center">
<img src="../resources/images/MpBR225.png" alt="Screen space versus view space." title="Screen space versus view space.">
</p>

<p>注意你可以在视空间中进行步进，<br />
但这样可能会对位置纹理进行欠采样或过采样。<br />
要记住位置帧缓冲纹理的尺寸和形状就是屏幕本身。<br />
每个屏幕像素对应摄像机拍摄到的某个位置。<br />
反射射线在视空间中可能走得很远，<br />
但在屏幕空间中可能只覆盖少量像素。<br />
你只能对屏幕像素进行采样，<br />
因此在视空间中步进可能会多次采样同一个像素，效率很低。<br />
而在屏幕空间中步进会更高效地采样真正覆盖到的像素。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>vec2 frag  <span class="op">=</span> startFrag<span class="op">.</span>xy<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>     uv<span class="op">.</span>xy <span class="op">=</span> frag <span class="op">/</span> texSize<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>第一步从反射射线的起点片元位置开始。<br />
将片元坐标除以位置纹理的尺寸，转换为 UV 坐标。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> deltaX    <span class="op">=</span> endFrag<span class="op">.</span>x <span class="op">-</span> startFrag<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> deltaY    <span class="op">=</span> endFrag<span class="op">.</span>y <span class="op">-</span> startFrag<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>计算终点和起点之间的 X、Y 坐标差值（delta）。<br />
这代表射线在屏幕空间中 X 和 Y 方向上占了多少像素。</p>
<p align="center">
<img src="../resources/images/Um4dzgL.png" alt="The reflection ray in screen space." title="The reflection ray in screen space.">
</p>

<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> useX      <span class="op">=</span> abs<span class="op">(</span>deltaX<span class="op">)</span> <span class="op">&gt;=</span> abs<span class="op">(</span>deltaY<span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> delta     <span class="op">=</span> mix<span class="op">(</span>abs<span class="op">(</span>deltaY<span class="op">),</span> abs<span class="op">(</span>deltaX<span class="op">),</span> useX<span class="op">)</span> <span class="op">*</span> clamp<span class="op">(</span>resolution<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>为了适配各种方向（垂直、水平、斜线等），<br />
你需要判断哪个方向的差值更大。<br />
较大的那个差值决定：</p>
<ul>
<li>每次迭代在 X 和 Y 上移动的量；</li>
<li>需要迭代多少次才能走完整条射线；</li>
<li>当前点在线上的相对位置百分比。</li>
</ul>
<p><code>useX</code> 是 0 或 1，<br />
用来选择 X 轴还是 Y 轴。<br />
<code>delta</code> 是两个差值中较大的一个，<br />
用于控制每次步进时的增量和总步数。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>vec2  increment <span class="op">=</span> vec2<span class="op">(</span>deltaX<span class="op">,</span> deltaY<span class="op">)</span> <span class="op">/</span> max<span class="op">(</span>delta<span class="op">,</span> <span class="fl">0.001</span><span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>根据较大的 delta 值计算每次 X 和 Y 上的增量。<br />
如果两个 delta 一样大，则每次都加 1。<br />
否则，大的那一维加 1，小的那一维加 &lt;1。<br />
假设 <code>resolution = 1</code>，<br />
当 <code>resolution &lt; 1</code> 时，算法就会跳过某些像素。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>startFrag  <span class="op">=</span> <span class="op">(</span> <span class="dv">1</span><span class="op">,</span>  <span class="dv">4</span><span class="op">)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>endFrag    <span class="op">=</span> <span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">14</span><span class="op">)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>deltaX     <span class="op">=</span> <span class="op">(</span><span class="dv">10</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>deltaY     <span class="op">=</span> <span class="op">(</span><span class="dv">14</span> <span class="op">-</span> <span class="dv">4</span><span class="op">)</span> <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>resolution <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>delta      <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> <span class="fl">0.5</span> <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>increment  <span class="op">=</span> <span class="op">(</span>deltaX<span class="op">,</span> deltaY<span class="op">)</span> <span class="op">/</span> delta</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>           <span class="op">=</span> <span class="op">(</span>     <span class="dv">9</span><span class="op">,</span>     <span class="dv">10</span><span class="op">)</span> <span class="op">/</span> <span class="dv">5</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>           <span class="op">=</span> <span class="op">(</span> <span class="dv">9</span> <span class="op">/</span> <span class="dv">5</span><span class="op">,</span>      <span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<p>例如，<code>resolution</code> 为 0.5 时，<br />
较大的维度每步进 2 像素而不是 1。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> search0 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> search1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>为了从起始片元移动到结束片元，算法使用线性插值：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>current position x <span class="op">=</span> <span class="op">(</span>start x<span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="dv">1</span> <span class="op">-</span> search1<span class="op">)</span> <span class="op">+</span> <span class="op">(</span>end x<span class="op">)</span> <span class="op">*</span> search1<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>current position y <span class="op">=</span> <span class="op">(</span>start y<span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="dv">1</span> <span class="op">-</span> search1<span class="op">)</span> <span class="op">+</span> <span class="op">(</span>end y<span class="op">)</span> <span class="op">*</span> search1<span class="op">;</span></span></code></pre></div>
<p><code>search1</code> 的取值范围是 0 到 1。</p>
<ul>
<li>当 <code>search1</code> 为 0 时，当前坐标等于起始片元；</li>
<li>当 <code>search1</code> 为 1 时，当前坐标等于结束片元；</li>
<li>当 <code>search1</code>
为其他值时，当前坐标在起始和结束片元之间。</li>
</ul>
<p><code>search0</code>
用来记录上一次光线没有命中场景几何体的位置。<br />
第二遍遍历时，算法会使用 <code>search0</code>
来帮助细化射线首次接触场景的位置。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> hit0 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> hit1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<ul>
<li><code>hit0</code> 表示第一次遍历期间发生了碰撞；</li>
<li><code>hit1</code> 表示第二次遍历期间发生了碰撞。</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> viewDistance <span class="op">=</span> startView<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> depth        <span class="op">=</span> thickness<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p><code>viewDistance</code> 是当前光线点离摄像机的距离。<br />
在 Panda3D 中，视空间的 Y 轴表示从屏幕外向内；<br />
在其他系统中，通常是 Z 轴。<br />
不管哪种方式，<code>viewDistance</code>
表示光线在当前点离摄像机的远近程度。</p>
<p>注意不要将 <code>viewDistance</code> 与屏幕上的 Y 轴混淆。<br />
<code>viewDistance</code> 表示的是视空间中的深度；<br />
而 Y 轴是在屏幕平面上上下移动。</p>
<p><code>depth</code>
是当前光线点的视距离与场景采样位置视距离之间的差值，<br />
用于判断该点是位于场景前方还是后方。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dt">int</span><span class="op">(</span>delta<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>现在可以开始第一次遍历了。<br />
第一次遍历在 <code>i &lt; delta</code> 时持续。<br />
当 <code>i == delta</code> 时，算法已经走完了整条反射线。</p>
<p align="center">
<img src="../resources/images/Qnsvkc0.gif" alt="Screen Space Transformations" title="Screen Space Transformations">
</p>

<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    frag      <span class="op">+=</span> increment<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span>xy      <span class="op">=</span> frag <span class="op">/</span> texSize<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    positionTo <span class="op">=</span> texture<span class="op">(</span>positionTexture<span class="op">,</span> uv<span class="op">.</span>xy<span class="op">);</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>将当前片元位置推进，靠近终点片元。<br />
使用这个新位置在位置贴图中采样场景的位置。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    search1 <span class="op">=</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>      mix</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span> <span class="op">(</span>frag<span class="op">.</span>y <span class="op">-</span> startFrag<span class="op">.</span>y<span class="op">)</span> <span class="op">/</span> deltaY</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> <span class="op">(</span>frag<span class="op">.</span>x <span class="op">-</span> startFrag<span class="op">.</span>x<span class="op">)</span> <span class="op">/</span> deltaX</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">,</span> useX</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>计算当前片元所占的线段百分比。<br />
如果 <code>useX == 0</code>，使用 Y 方向；否则使用 X 方向。</p>
<ul>
<li>当 <code>frag == startFrag</code>，<code>search1 == 0</code>；</li>
<li>当 <code>frag == endFrag</code>，<code>search1 == 1</code>；</li>
<li>中间值表示当前在射线线段上的相对位置。</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    viewDistance <span class="op">=</span> <span class="op">(</span>startView<span class="op">.</span>y <span class="op">*</span> endView<span class="op">.</span>y<span class="op">)</span> <span class="op">/</span> mix<span class="op">(</span>endView<span class="op">.</span>y<span class="op">,</span> startView<span class="op">.</span>y<span class="op">,</span> search1<span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>使用 <code>search1</code> 来插值当前点在视空间中的距离。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 错误方式</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>viewDistance <span class="op">=</span> mix<span class="op">(</span>startView<span class="op">.</span>y<span class="op">,</span> endView<span class="op">.</span>y<span class="op">,</span> search1<span class="op">);</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 正确方式</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>viewDistance <span class="op">=</span> <span class="op">(</span>startView<span class="op">.</span>y <span class="op">*</span> endView<span class="op">.</span>y<span class="op">)</span> <span class="op">/</span> mix<span class="op">(</span>endView<span class="op">.</span>y<span class="op">,</span> startView<span class="op">.</span>y<span class="op">,</span> search1<span class="op">);</span></span></code></pre></div>
<p>尽管你可能会尝试直接用 <code>mix</code>
插值视距离，但这会导致误差。<br />
应使用透视修正插值（perspective-correct interpolation）。</p>
<p>参考：<a
href="https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf">Perspective-Correct
Interpolation</a></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    depth        <span class="op">=</span> viewDistance <span class="op">-</span> positionTo<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>计算光线当前点的视距与场景采样位置的视距之间的差值。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>depth <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> depth <span class="op">&lt;</span> thickness<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>      hit0 <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>      search0 <span class="op">=</span> search1<span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>如果差值在 0 和 <code>thickness</code> 之间，说明碰撞发生了。<br />
设置 <code>hit0 = 1</code>，并跳出第一次遍历。<br />
否则记录当前 <code>search1</code> 为
<code>search0</code>，继续步进。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  search1 <span class="op">=</span> search0 <span class="op">+</span> <span class="op">((</span>search1 <span class="op">-</span> search0<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>第一次遍历结束后，将 <code>search1</code> 设为最后一次 miss 与 hit
之间的中点。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  steps <span class="op">*=</span> hit0<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> steps<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>开始第二次遍历。如果第一次遍历没有碰撞（<code>hit0 == 0</code>），跳过这一步。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    frag       <span class="op">=</span> mix<span class="op">(</span>startFrag<span class="op">.</span>xy<span class="op">,</span> endFrag<span class="op">.</span>xy<span class="op">,</span> search1<span class="op">);</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span>xy      <span class="op">=</span> frag <span class="op">/</span> texSize<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    positionTo <span class="op">=</span> texture<span class="op">(</span>positionTexture<span class="op">,</span> uv<span class="op">.</span>xy<span class="op">);</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>像第一次遍历那样，采样当前射线位置对应的场景坐标。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    viewDistance <span class="op">=</span> <span class="op">(</span>startView<span class="op">.</span>y <span class="op">*</span> endView<span class="op">.</span>y<span class="op">)</span> <span class="op">/</span> mix<span class="op">(</span>endView<span class="op">.</span>y<span class="op">,</span> startView<span class="op">.</span>y<span class="op">,</span> search1<span class="op">);</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    depth        <span class="op">=</span> viewDistance <span class="op">-</span> positionTo<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>计算当前点的视距，并与场景视距做差。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>depth <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> depth <span class="op">&lt;</span> thickness<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>      hit1 <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>      search1 <span class="op">=</span> search0 <span class="op">+</span> <span class="op">((</span>search1 <span class="op">-</span> search0<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">float</span> temp <span class="op">=</span> search1<span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      search1 <span class="op">=</span> search1 <span class="op">+</span> <span class="op">((</span>search1 <span class="op">-</span> search0<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>      search0 <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>若深度差值在合法范围内，说明命中；设置 <code>hit1 = 1</code>，<br />
更新 <code>search1</code> 为 miss 和当前 hit 的中点。<br />
如果没有命中，更新 <code>search0</code> 和
<code>search1</code>，继续二分。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> visibility <span class="op">=</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>      hit1</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>第二次遍历结束，准备计算最终反射的可见性（visibility）。<br />
<code>visibility</code> 的取值范围是 0 到 1；<br />
若未命中，值为 0。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> positionTo<span class="op">.</span>w</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>如果采样点的 alpha 分量为 0（即
<code>w == 0</code>），则说明没有场景信息。<br />
此时 <code>visibility == 0</code>。</p>
<p align="center">
<img src="../resources/images/7e2cOdZ.gif" alt="Reflection ray pointing towards the camera position." title="Reflection ray pointing towards the camera position.">
</p>

<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="op">(</span> <span class="dv">1</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">-</span> max</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>         <span class="op">(</span> dot<span class="op">(-</span>unitPositionFrom<span class="op">,</span> pivot<span class="op">)</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> <span class="dv">0</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>         <span class="op">)</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>当反射向量朝向摄像机时，可能会出现 SSR 错误。<br />
为了解决这一问题，使用 dot 值对反射做渐变衰减。</p>
<ul>
<li>dot 为 -1（完全相反）时，<code>visibility = 1</code></li>
<li>dot 为 1（完全相同方向）时，<code>visibility = 0</code></li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="op">(</span> <span class="dv">1</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">-</span> clamp</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">(</span> depth <span class="op">/</span> thickness</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">,</span> <span class="dv">0</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">,</span> <span class="dv">1</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">)</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>如果你没能准确找到交点，可以根据差值与 <code>thickness</code>
的比值进行模糊衰减。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="op">(</span> <span class="dv">1</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">-</span> clamp</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">(</span>   length<span class="op">(</span>positionTo <span class="op">-</span> positionFrom<span class="op">)</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">/</span> maxDistance</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">,</span> <span class="dv">0</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">,</span> <span class="dv">1</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">)</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">)</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>根据反射点与起点之间的距离进行进一步衰减，<br />
避免反射突然中断。</p>
<p align="center">
<img src="../resources/images/i0btBna.gif" alt="Reflection ray exiting the frustum." title="Reflection ray exiting the frustum.">
</p>

<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="op">(</span>uv<span class="op">.</span>x <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> uv<span class="op">.</span>x <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="op">(</span>uv<span class="op">.</span>y <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> uv<span class="op">.</span>y <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>如果 UV 坐标超出了 [0, 1]
范围，表示光线跑出视锥体，<code>visibility = 0</code>。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>  visibility <span class="op">=</span> clamp<span class="op">(</span>visibility<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  uv<span class="op">.</span>ba <span class="op">=</span> vec2<span class="op">(</span>visibility<span class="op">);</span></span></code></pre></div>
<p>将 visibility 存储在 uv 向量的蓝色和 alpha 分量中；红绿分量是 UV
坐标。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  fragColor <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>最终片元颜色即为反射 UV 坐标（uv.rg）以及其可见性（uv.ba）。</p>
<h3 id="高光贴图specular-map">高光贴图（Specular Map）</h3>
<p align="center">
<img src="../resources/images/iuFYVWB.gif" alt="Specular Map" title="Specular Map">
</p>

<p>除了反射 UV 坐标之外，你还需要一个高光贴图。<br />
示例代码使用片元材质的高光属性来创建它：</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAX_SHININESS </span><span class="fl">127.75</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>uniform <span class="kw">struct</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> vec3 specular</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">;</span> <span class="dt">float</span> shininess</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">;</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> p3d_Material<span class="op">;</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>out vec4 fragColor<span class="op">;</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>  fragColor <span class="op">=</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    vec4</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span> p3d_Material<span class="op">.</span>specular</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">,</span> clamp<span class="op">(</span>p3d_Material<span class="op">.</span>shininess <span class="op">/</span> MAX_SHININESS<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">);</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这个高光片元着色器非常简单。<br />
它使用片元的材质信息输出高光颜色，并将 alpha
通道用于光泽度（shininess）。<br />
光泽度被映射到 0 到 1 的范围内。<br />
在 Blender 中，最高的高光硬度（shininess）是 511，<br />
从 Blender 导出到 Panda3D 时，511 被转换为 127.75。<br />
你可以根据自己的需求调整这个值，使它落在 0 到 1 的范围内。</p>
<p>示例代码根据材质高光属性生成高光贴图，<br />
但你也可以在 GIMP 等软件中手动绘制，并作为纹理附加到你的 3D 模型上。</p>
<p>比如：<br />
假设你的 3D 宝箱上有一些闪亮的金属扣件，但其它部分不需要反射环境。<br />
你可以将扣件绘制为灰色，而将其它区域涂成黑色。<br />
这样，shader 就会只在扣件区域渲染反射，而忽略其它部分。</p>
<hr />
<h3 id="场景颜色scene-colors">场景颜色（Scene Colors）</h3>
<p align="center">
<img src="../resources/images/diBSxPI.png" alt="Scene Colors" title="Scene Colors">
</p>

<p>你需要渲染场景中希望被反射的部分，并将其存储到一个 framebuffer
纹理中。<br />
这通常是未加反射效果的场景。</p>
<hr />
<h3
id="被反射的场景颜色reflected-scene-colors">被反射的场景颜色（Reflected
Scene Colors）</h3>
<p align="center">
<img src="../resources/images/UPvgfDU.gif" alt="Reflected Scene Colors" title="Reflected Scene Colors">
</p>

<p>上图展示了保存到 framebuffer 纹理中的反射颜色。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>uniform sampler2D uvTexture<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>uniform sampler2D colorTexture<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>一旦你得到了反射的 UV 坐标，查找反射颜色就很简单了。<br />
你需要：</p>
<ul>
<li>一个反射 UV 坐标纹理（<code>uvTexture</code>）；</li>
<li>一个包含待反射颜色的颜色纹理（<code>colorTexture</code>）。</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  vec2 texSize  <span class="op">=</span> textureSize<span class="op">(</span>uvTexture<span class="op">,</span> <span class="dv">0</span><span class="op">).</span>xy<span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  vec2 texCoord <span class="op">=</span> gl_FragCoord<span class="op">.</span>xy <span class="op">/</span> texSize<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  vec4 uv    <span class="op">=</span> texture<span class="op">(</span>uvTexture<span class="op">,</span>    texCoord<span class="op">);</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  vec4 color <span class="op">=</span> texture<span class="op">(</span>colorTexture<span class="op">,</span> uv<span class="op">.</span>xy<span class="op">);</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>使用当前片元的 UV 坐标，在颜色纹理中查找反射颜色。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> alpha <span class="op">=</span> clamp<span class="op">(</span>uv<span class="op">.</span>b<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>回忆一下：反射 UV
纹理将可见性（visibility）存储在蓝色（B）通道中。<br />
这将作为反射颜色 framebuffer 的 alpha 通道。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  fragColor <span class="op">=</span> vec4<span class="op">(</span>mix<span class="op">(</span>vec3<span class="op">(</span><span class="dv">0</span><span class="op">),</span> color<span class="op">.</span>rgb<span class="op">,</span> alpha<span class="op">),</span> alpha<span class="op">);</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>最终的片元颜色是根据可见性 <code>alpha</code>
在黑色与反射颜色之间进行插值的结果。<br />
可见性值是在反射 UV 坐标计算步骤中求出的。</p>
<h3 id="高光贴图specular-map-1">高光贴图（Specular Map）</h3>
<p align="center">
<img src="../resources/images/iuFYVWB.gif" alt="Specular Map" title="Specular Map">
</p>

<p>除了反射 UV
坐标之外，你还需要一个高光贴图。示例代码使用片元的材质高光属性创建该贴图：</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>\#define MAX\_SHININESS <span class="fl">127.75</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>uniform <span class="kw">struct</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> vec3 specular</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="op">;</span> <span class="dt">float</span> shininess</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> p3d\_Material<span class="op">;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>out vec4 fragColor<span class="op">;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>vec4</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="op">(</span> p3d\_Material<span class="op">.</span>specular</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="op">,</span> clamp<span class="op">(</span>p3d\_Material<span class="op">.</span>shininess <span class="op">/</span> MAX\_SHININESS<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>该高光着色器非常简单。使用材质的高光颜色作为输出的 RGB 值，
并将光泽度（shininess）通过映射后的 alpha 值输出。 光泽度被映射到 0 到 1
范围内。Blender 中最大 shininess 是 511， 但导出到 Panda3D 时会转换为
127.75。你可以根据具体需求调整这个范围。</p>
<p>上述代码是通过材质的高光属性动态生成高光贴图， 但你也可以使用 GIMP
等工具手动绘制灰度图作为贴图。</p>
<p>例如： 你的 3D 宝箱模型中只有金属扣件需要反射，其它部分不需要。
你可以将金属扣件区域涂成灰色，其它区域涂成黑色。 Shader
将根据这个贴图，仅在灰色区域渲染反射效果。</p>
<hr />
<h3 id="场景颜色scene-colors-1">场景颜色（Scene Colors）</h3>
<p align="center">
<img src="../resources/images/diBSxPI.png" alt="Scene Colors" title="Scene Colors">
</p>

<p>你需要渲染希望被反射的场景部分，并将其存入 framebuffer 纹理中。
通常该场景不包含反射，仅是基本渲染结果。</p>
<hr />
<h3
id="被反射的场景颜色reflected-scene-colors-1">被反射的场景颜色（Reflected
Scene Colors）</h3>
<p align="center">
<img src="../resources/images/UPvgfDU.gif" alt="Reflected Scene Colors" title="Reflected Scene Colors">
</p>

<p>下图展示了保存反射颜色的 framebuffer 纹理：</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>uniform sampler2D uvTexture<span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>uniform sampler2D colorTexture<span class="op">;</span></span></code></pre></div>
<p>获取反射颜色的方式是：</p>
<ul>
<li>读取反射 UV 坐标纹理 <code>uvTexture</code>；</li>
<li>用该坐标在颜色纹理 <code>colorTexture</code> 中查找颜色。</li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>vec2 texSize  <span class="op">=</span> textureSize<span class="op">(</span>uvTexture<span class="op">,</span> <span class="dv">0</span><span class="op">).</span>xy<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>vec2 texCoord <span class="op">=</span> gl\_FragCoord<span class="op">.</span>xy <span class="op">/</span> texSize<span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>vec4 uv    <span class="op">=</span> texture<span class="op">(</span>uvTexture<span class="op">,</span>    texCoord<span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>vec4 color <span class="op">=</span> texture<span class="op">(</span>colorTexture<span class="op">,</span> uv<span class="op">.</span>xy<span class="op">);</span></span></code></pre></div>
<p>当前片元坐标用作查找反射 UV 的索引，再利用反射 UV 查找反射颜色。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> alpha <span class="op">=</span> clamp<span class="op">(</span>uv<span class="op">.</span>b<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>反射 UV 纹理的 B（蓝色）通道存储的是 visibility 值，
该值在反射颜色纹理中作为 alpha 通道使用。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> vec4<span class="op">(</span>mix<span class="op">(</span>vec3<span class="op">(</span><span class="dv">0</span><span class="op">),</span> color<span class="op">.</span>rgb<span class="op">,</span> alpha<span class="op">),</span> alpha<span class="op">);</span></span></code></pre></div>
<p>最终颜色是在黑色和反射颜色之间基于 visibility 的插值。 这个
visibility 是在计算反射 UV 坐标阶段确定的。</p>
<hr />
<h3
id="模糊的反射颜色blurred-reflected-scene-colors">模糊的反射颜色（Blurred
Reflected Scene Colors）</h3>
<p align="center">
<img src="../resources/images/gVvx1Ei.png" alt="Blurred Reflected Scene Colors" title="Blurred Reflected Scene Colors">
</p>

<p>现在对反射颜色进行模糊处理，并将其写入 framebuffer。模糊使用 box blur
算法， 参考 <a href="ssao.html#blurring">SSAO 模糊处理</a> 一节。</p>
<p>模糊反射颜色用于非镜面材质表面，例如表面有细微粗糙度时，反射应被模糊处理。
这部分将在 roughness 粗糙度计算时进一步讨论。</p>
<hr />
<h3 id="最终反射合成reflections">最终反射合成（Reflections）</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>uniform sampler2D colorTexture<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>uniform sampler2D colorBlurTexture<span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>uniform sampler2D specularTexture<span class="op">;</span></span></code></pre></div>
<p>最终合成需要三个纹理：反射颜色、模糊反射颜色和高光贴图。</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>vec4 specular  <span class="op">=</span> texture<span class="op">(</span>specularTexture<span class="op">,</span>  texCoord<span class="op">);</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>vec4 color     <span class="op">=</span> texture<span class="op">(</span>colorTexture<span class="op">,</span>     texCoord<span class="op">);</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>vec4 colorBlur <span class="op">=</span> texture<span class="op">(</span>colorBlurTexture<span class="op">,</span> texCoord<span class="op">);</span></span></code></pre></div>
<p>获取当前像素的高光信息、反射颜色和模糊反射颜色。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> specularAmount <span class="op">=</span> dot<span class="op">(</span>specular<span class="op">.</span>rgb<span class="op">,</span> vec3<span class="op">(</span><span class="dv">1</span><span class="op">))</span> <span class="op">/</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>specularAmount <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> vec4<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span><span class="op">;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>将 RGB 高光颜色转为灰度值作为反射强度。 如果该值为
0，则不显示反射。</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>dot<span class="op">(</span>specular<span class="op">.</span>rgb<span class="op">,</span> vec3<span class="op">(</span><span class="dv">1</span><span class="op">))</span> <span class="op">==</span> <span class="op">(</span>specular<span class="op">.</span>r <span class="op">+</span> specular<span class="op">.</span>g <span class="op">+</span> specular<span class="op">.</span>b<span class="op">);</span></span></code></pre></div>
<p>使用点积简写将 RGB 三通道相加转为灰度值。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> roughness <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> min<span class="op">(</span>specular<span class="op">.</span>a<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>利用高光贴图的 alpha 通道（存储的是 shininess）计算粗糙度 roughness。
shininess 越大，反射越锐利，roughness 越小；shininess
越小，反射越模糊。</p>
<p>你也可以通过绘制 roughness 贴图（例如在 GIMP
中），标识哪些区域表面光滑，哪些区域粗糙。
例如一块瓷砖地面有些区域抛光，有些区域刮花。
可将抛光区域设为接近黑色（低 roughness），刮花区域设为接近白色（高
roughness）。 shader 会据此决定使用清晰反射还是模糊反射。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> mix<span class="op">(</span>color<span class="op">,</span> colorBlur<span class="op">,</span> roughness<span class="op">)</span> \<span class="op">*</span> specularAmount<span class="op">;</span></span></code></pre></div>
<p>使用 roughness 在 color（清晰反射）和 colorBlur（模糊反射）之间插值。
再乘以 specularAmount 得到最终颜色。</p>
<hr />
<h3 id="源码参考">源码参考</h3>
<ul>
<li><a href="https://github.com/lettier/3d-game-shaders-for-beginners/blob/master/demonstration/src/main.cxx" target="_blank" rel="noopener noreferrer">main.cxx</a></li>
<li><a
href="../demonstration/shaders/vertex/base.vert">base.vert</a></li>
<li><a
href="../demonstration/shaders/vertex/basic.vert">basic.vert</a></li>
<li><a
href="../demonstration/shaders/fragment/position.frag">position.frag</a></li>
<li><a
href="../demonstration/shaders/fragment/normal.frag">normal.frag</a></li>
<li><a
href="../demonstration/shaders/fragment/material-specular.frag">material-specular.frag</a></li>
<li><a
href="../demonstration/shaders/fragment/screen-space-reflection.frag">screen-space-reflection.frag</a></li>
<li><a
href="../demonstration/shaders/fragment/reflection-color.frag">reflection-color.frag</a></li>
<li><a
href="../demonstration/shaders/fragment/reflection.frag">reflection.frag</a></li>
<li><a
href="../demonstration/shaders/fragment/box-blur.frag">box-blur.frag</a></li>
<li><a
href="../demonstration/shaders/fragment/base-combine.frag">base-combine.frag</a></li>
</ul>
<h2 id="copyright">Copyright</h2>
<p>(C) 2019 David Lettier <br> <a
href="https://www.lettier.com">lettier.com</a></p>
<p><a href="chromatic-aberration.html"><span class="emoji"
data-emoji="arrow_backward">◀️</span></a> <a href="../README.md"><span
class="emoji" data-emoji="arrow_double_up">⏫</span></a> <a
href="#"><span class="emoji" data-emoji="arrow_up_small">🔼</span></a>
<a href="#copyright"><span class="emoji"
data-emoji="arrow_down_small">🔽</span></a> <a
href="screen-space-refraction.html"><span class="emoji"
data-emoji="arrow_forward">▶️</span></a></p>
  </body>
</html>
